package src.compilers;

import utils.PrepareMacro;
import sys.io.File;
import sys.FileSystem;
import src.JsonFile;
import src.SlushiUtils;
import src.Main;

/**
 * The Haxe compiler, a class that handles the compilation of Haxe projects using
 * the Haxe compiler iself and a HXML file (https://haxe.org/manual/compiler-usage-hxml.html).
 * 
 * Author: Slushi.
 */

class GenerateHaxeDocs {
	static var jsonFile:JsonStruct = JsonFile.getJson();
	static final hxmlFileName:String = "doxTemphxml";
	static var exitCodeNum:Int = 0;

	public static function init() {
		if (jsonFile == null) {
			SlushiUtils.printMsg("Error loading [hxCompileUConfig.json]", ERROR);
			return;
		}

		// Check if all required fields are set
		if (jsonFile.haxeConfig.sourceDir == "") {
			SlushiUtils.printMsg("sourceDir in [hxCompileUConfig.json -> haxeConfig.sourceDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.hxMain == "") {
			SlushiUtils.printMsg("hxMain in [hxCompileUConfig.json -> haxeConfig.hxMain] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.outDir == "") {
			SlushiUtils.printMsg("outDir in [hxCompileUConfig.json -> haxeConfig.outDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		}

		SlushiUtils.printMsg("Trying to compile Haxe project...", PROCESSING);
		SlushiUtils.printMsg('Creating [${hxmlFileName}.hxml]', PROCESSING);

		// make a temporal HXML
		try {
			var hxml:String = '
# File generated by HxCompileU v${Main.version}
	# Main parameters
	-cp ${jsonFile.haxeConfig.sourceDir}
	-main ${jsonFile.haxeConfig.hxMain}
	-lib reflaxe.cpp
	-lib hxwut
	-D cxx-no-null-warnings
	${generateMacro()}
	#####
	${finalHxLibs()}
	# Extra Libs
	# Extra defines
	${finalHxDefines()}
	# Extra options
	${finalOtherOptions()}
	# Macros
';
			// delete temporal hxml if already exists
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
				SlushiUtils.printMsg('Deleted existing [${hxmlFileName}.hxml]', INFO);
			}
			File.saveContent(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml', hxml);
		} catch (e) {
			SlushiUtils.printMsg('Error creating [${hxmlFileName}.hxml]: ${e}', ERROR);
			exitCodeNum = 4;
			return;
		}

		SlushiUtils.printMsg('Created [${hxmlFileName}.hxml]', SUCCESS);
		SlushiUtils.printMsg("Compiling Haxe project...\n------------------", PROCESSING);

		var startTime:Float = Sys.time();

		var compileProcess = null;
		if (jsonFile.haxeConfig.debugMode) {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml', '--debug']);
		} else {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml']);
		}

		SlushiUtils.printMsg("------------------\n", NONE);

		var endTime:Float = Sys.time();
		var elapsedTime:Float = endTime - startTime;
		var formattedTime:String = StringTools.trim(Math.fround(elapsedTime * 10) / 10 + "s");

		if (compileProcess != 0) {
			SlushiUtils.printMsg("Compilation failed", ERROR);
			exitCodeNum = 2;
		}

		// delete temporal hxml
		if (jsonFile.deleteTempFiles == true) {
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
			}
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros/HXCU_MACRO.hx")) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros/HXCU_MACRO.hx");
			}
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros")) {
				FileSystem.deleteDirectory(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros");
			}
		}

		if (exitCodeNum == 0) {
			SlushiUtils.printMsg('Compilation successful, compilation time: ${formattedTime}\n', SUCCESS);
		}
	}

	public static function getExitCode():Int {
		return exitCodeNum;
	}

	static function finalHxLibs():String {
		var libs = "";

		for (lib in Libs.parseHXLibs()) {
			libs += lib + "\n\t";
		}

		return libs;
	}

	static function finalHxDefines():String {
		var defines = "";

		for (define in Defines.parseHXDefines()) {
			defines += define + "\n";
		}

		return defines;
	}

	static function finalOtherOptions():String {
		var options = "";

		for (option in Defines.parseOtherOptions()) {
			options += option + "\n";
		}

		return options;
	}

	static function generateMacro():String {
		var macroStr:String = "";
		var checkResult:MacroFinalCheck = PrepareMacro.check();

		switch (checkResult) {
			case MACRO_ERROR:
				SlushiUtils.printMsg("Error checking macros", ERROR);
				return "";
			case MACRO_SKIP:
				return "";
			case MACRO_OK:
			default:
				return "";
		}
		
		for (lib in 0...PrepareMacro.libsRequiringMacrosArray.length) {
			macroStr += "--macro " + jsonFile.haxeConfig.sourceDir + ".hxCompileUMacros.HXCU_MACRO.InitMacroFunction()\n";
			PrepareMacro.searchLibInHaxeLibsAndSetHxFile(PrepareMacro.libsRequiringMacrosArray[lib]);
		}

		return macroStr;
	}
}
