// Copyright (c) 2025 AndrÃ©s E. G.
//
// This software is licensed under the MIT License.
// See the LICENSE file for more details.


package src.compilers;

import src.utils.LibsManager;
import sys.io.File;
import sys.FileSystem;
import src.JsonFile;
import src.SlushiUtils;
import src.Main;

/**
 * The Haxe compiler, a class that handles the compilation of Haxe projects using
 * the Haxe compiler iself and a HXML file (https://haxe.org/manual/compiler-usage-hxml.html).
 * 
 * Author: Slushi.
 */

class HaxeCompiler {
	static var jsonFile:JsonStruct = JsonFile.getJson();
	static final hxmlFileName:String = "temphxml";
	static var exitCodeNum:Int = 0;

	public static var forceDebugMode:Bool = false;

	public static function init():Void {
		if (jsonFile == null) {
			SlushiUtils.printMsg("Error loading [hxCompileUConfig.json]", ERROR);
			return;
		}

		// Check if all required fields are set
		if (jsonFile.haxeConfig.sourceDir == "") {
			SlushiUtils.printMsg("sourceDir in [hxCompileUConfig.json -> haxeConfig.sourceDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.hxMain == "") {
			SlushiUtils.printMsg("hxMain in [hxCompileUConfig.json -> haxeConfig.hxMain] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.outDir == "") {
			SlushiUtils.printMsg("outDir in [hxCompileUConfig.json -> haxeConfig.outDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		}

		var reportStyle:String = jsonFile.haxeConfig.errorReportingStyle;
		var validStyles = ["classic", "indent", "pretty"];
		var style = jsonFile.haxeConfig.errorReportingStyle;
		if (style == "" || !Lambda.has(validStyles, style)) {
			SlushiUtils.printMsg("errorReportingStyle in [hxCompileUConfig.json -> haxeConfig.errorReportingStyle] is invalid ("
				+ style
				+ "), using [classic]", WARN);
			reportStyle = "classic";
		} else {
			reportStyle = style;
		}

		SlushiUtils.printMsg("Trying to compile Haxe project...", PROCESSING);
		SlushiUtils.printMsg('Creating [${hxmlFileName}.hxml]', PROCESSING);

		// make a temporal HXML
		try {
			var hxml:String = '
# File generated by HxCompileU v${Main.version}
	# Main parameters
	-cp ${jsonFile.haxeConfig.sourceDir}
	-main ${jsonFile.haxeConfig.hxMain}
	-lib reflaxe.cpp
	-lib hxu_wut
	-D cpp-output=${jsonFile.haxeConfig.outDir}
	-D mainClass=${jsonFile.haxeConfig.hxMain}
	-D cxx-no-null-warnings
	-D message.reporting=${reportStyle}
	# Extra Libs
	${finalHxLibs()}
	# Extra defines
	${finalHxDefines()}
	# Extra options
	${finalOtherOptions()}
';
			// if the project is a plugin, add the libmappedmemory library
			if (jsonFile.wiiuConfig.isAPlugin == true) {
				hxml += '\n
	# WUPS library preparation
	-lib hxu_libmappedmemory
';
			}

			// delete temporal hxml if already exists
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
				SlushiUtils.printMsg('Deleted existing [${hxmlFileName}.hxml]', INFO);
			}
			File.saveContent(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml', hxml);
		} catch (e) {
			SlushiUtils.printMsg('Error creating [${hxmlFileName}.hxml]: ${e}', ERROR);
			exitCodeNum = 4;
			return;
		}

		var debugMode:Bool = forceDebugMode ? true : (jsonFile.haxeConfig.debugMode == true);

		SlushiUtils.printMsg('Created [${hxmlFileName}.hxml]', SUCCESS);

		if (debugMode) {
			SlushiUtils.printMsg("Haxe debug mode is enabled", INFO);
		}

		SlushiUtils.printMsg("Compiling Haxe project...\n------------------", PROCESSING);

		var startTime:Float = Sys.time();

		var compileProcess = null;

		if (debugMode) {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml', '--debug']);
		} else {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml']);
		}

		if (compileProcess != 0) {
			SlushiUtils.printMsg("\x1b[38;5;1m------------------\033[0m", NONE);
		} else {
			SlushiUtils.printMsg("\x1b[38;5;71m------------------\033[0m", NONE);
		}

		var endTime:Float = Sys.time();
		var elapsedTime:Float = endTime - startTime;
		var formattedTime:String = StringTools.trim(Math.fround(elapsedTime * 10) / 10 + "s");

		if (compileProcess != 0) {
			SlushiUtils.printMsg("\x1b[38;5;178mHaxe\033[0m compilation failed", ERROR);
			exitCodeNum = 2;
		}

		// delete temporal hxml and macros
		if (jsonFile.deleteTempFiles == true) {
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
			}
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros/HXCU_MACRO.hx")) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros/HXCU_MACRO.hx");
			}
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros")) {
				FileSystem.deleteDirectory(SlushiUtils.getPathFromCurrentTerminal() + jsonFile.haxeConfig.sourceDir + "/hxCompileUMacros");
			}
		}

		if (exitCodeNum == 0) {
			SlushiUtils.printMsg('\x1b[38;5;178mHaxe\033[0m compilation successful, compilation time: ${formattedTime}\n', SUCCESS);
		}
	}

	public static function getExitCode():Int {
		return exitCodeNum;
	}

	static function finalHxLibs():String {
		var libs = "";

		for (lib in LibsManager.parseHXLibs()) {
			libs += lib + "\n\t";
		}

		return libs;
	}

	static function finalHxDefines():String {
		var defines = "";

		for (define in Defines.parseHXDefines()) {
			defines += define + "\n";
		}

		return defines;
	}

	static function finalOtherOptions():String {
		var options = "";

		for (option in Defines.parseOtherOptions()) {
			options += option + "\n";
		}

		return options;
	}
}
