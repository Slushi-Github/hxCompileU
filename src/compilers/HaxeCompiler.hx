package src.compilers;

import sys.io.Process;
import sys.io.File;
import sys.FileSystem;
import src.JsonFile;
import src.SlushiUtils;
import src.Main;

class HaxeCompiler {
	static var jsonFile:JsonStruct = JsonFile.getJson();
	static final hxmlFileName:String = "temphxml";
	static var exitCodeNum:Int = 0;

	public static function init() {
		if (jsonFile == null) {
			SlushiUtils.printMsg("Error loading [hxCompileUConfig.json]", "error");
			return;
		}

		// Check if all required fields are set
		if (jsonFile.haxeConfig.sourceDir == "") {
			SlushiUtils.printMsg("sourceDir in [hxCompileUConfig.json -> haxeConfig.sourceDir] is empty", "error");
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.hxMain == "") {
			SlushiUtils.printMsg("hxMain in [hxCompileUConfig.json -> haxeConfig.hxMain] is empty", "error");
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.outDir == "") {
			SlushiUtils.printMsg("outDir in [hxCompileUConfig.json -> haxeConfig.outDir] is empty", "error");
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.reportErrorStyle == "") {
			SlushiUtils.printMsg("reportErrorStyle in [hxCompileUConfig.json -> haxeConfig.reportErrorStyle] is empty", "error");
			exitCodeNum = 3;
			return;
		}

		SlushiUtils.printMsg("Trying to compile Haxe project...", "processing");

		SlushiUtils.printMsg('Creating [${hxmlFileName}.hxml]', "processing");
		// make a temporal HXML
		try {
			var hxml:String = '
			# File generated by HxCompileU v${Main.version}
                -cp ${jsonFile.haxeConfig.sourceDir}
                -main ${jsonFile.haxeConfig.hxMain}
                -lib reflaxe.cpp
                -D cpp-output=${jsonFile.haxeConfig.outDir}
                -D report-error-style=${jsonFile.haxeConfig.reportErrorStyle}
                -D mainClass=${jsonFile.haxeConfig.hxMain}
            ';

			// ${parseLibs()}
			// ${parseDefines()}

			// delete temporal hxml if already exists
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
				SlushiUtils.printMsg("Deleted existing [${hxmlFileName}.hxml]", "info");
			}
			File.saveContent(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml', hxml);
		} catch (e) {
			SlushiUtils.printMsg('Error creating [${hxmlFileName}.hxml]: ${e}', "error");
			exitCodeNum = 4;
			return;
		}

		SlushiUtils.printMsg('Created [${hxmlFileName}.hxml]', "success");
		SlushiUtils.printMsg("Compiling Haxe project...\n", "info");

		var compileProcess = null;
		if (jsonFile.haxeConfig.debugMode) {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml', '--debug']);
		} else {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml']);
		}
		if (compileProcess != 0) {
			SlushiUtils.printMsg("Compilation failed", "error", "\n");
			exitCodeNum = 2;
		}

		// delete temporal hxml
		if (jsonFile.deleteTempFiles == true) {
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
			}
		}

		if (exitCodeNum == 0) {
			SlushiUtils.printMsg("Compilation successful", "success", "\n");
		}
	}

	public static function getExitCode():Int {
		return exitCodeNum;
	}

	static function parseLibs():String {
		var libs = "";

		if (jsonFile.haxeConfig.hxLibs == null || jsonFile.haxeConfig.hxLibs.length == 0) {
			return "";
		}

		for (i in 0...jsonFile.haxeConfig.hxLibs.length) {
			libs += "-lib " + jsonFile.haxeConfig.hxLibs[i] + "\n";
		}

		return libs;
	}

	static function parseDefines():String {
		var defines = "";

		if (jsonFile.haxeConfig.hxDefines == null || jsonFile.haxeConfig.hxDefines.length == 0) {
			return "";
		}

		for (i in 0...jsonFile.haxeConfig.hxDefines.length) {
			defines += "-D " + jsonFile.haxeConfig.hxDefines[i] + "\n";
		}

		return defines;
	}
}
