package src.compilers;

import sys.io.Process;
import sys.io.File;
import sys.FileSystem;
import src.JsonFile;
import src.SlushiUtils;
import src.Main;

class HaxeCompiler {
	static var jsonFile:JsonStruct = JsonFile.getJson();
	static final hxmlFileName:String = "temphxml";
	static var exitCodeNum:Int = 0;

	public static function init() {
		if (jsonFile == null) {
			SlushiUtils.printMsg("Error loading [hxCompileUConfig.json]", ERROR);
			return;
		}

		// Check if all required fields are set
		if (jsonFile.haxeConfig.sourceDir == "") {
			SlushiUtils.printMsg("sourceDir in [hxCompileUConfig.json -> haxeConfig.sourceDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.hxMain == "") {
			SlushiUtils.printMsg("hxMain in [hxCompileUConfig.json -> haxeConfig.hxMain] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.outDir == "") {
			SlushiUtils.printMsg("outDir in [hxCompileUConfig.json -> haxeConfig.outDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.reportErrorStyle == "") {
			SlushiUtils.printMsg("reportErrorStyle in [hxCompileUConfig.json -> haxeConfig.reportErrorStyle] is empty", ERROR);
			exitCodeNum = 3;
			return;
		}

		SlushiUtils.printMsg("Trying to compile Haxe project...", PROCESSING);

		SlushiUtils.printMsg('Creating [${hxmlFileName}.hxml]', PROCESSING);
		// make a temporal HXML
		try {
			var hxml:String = '
# File generated by HxCompileU v${Main.version}
	# Main parameters
	-cp ${jsonFile.haxeConfig.sourceDir}
	-main ${jsonFile.haxeConfig.hxMain}
	-lib reflaxe.cpp
	-lib hxwut
	-D cpp-output=${jsonFile.haxeConfig.outDir}
	-D report-error-style=${jsonFile.haxeConfig.reportErrorStyle}
	-D mainClass=${jsonFile.haxeConfig.hxMain}
	# Extra Libs
	${finalHxLibs()}
	# Extra defines
	${finalHxDefines()}
	# Extra options
	${finalOtherOptions()}
';
			// delete temporal hxml if already exists
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
				SlushiUtils.printMsg('Deleted existing [${hxmlFileName}.hxml]', INFO);
			}
			File.saveContent(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml', hxml);
		} catch (e) {
			SlushiUtils.printMsg('Error creating [${hxmlFileName}.hxml]: ${e}', ERROR);
			exitCodeNum = 4;
			return;
		}

		SlushiUtils.printMsg('Created [${hxmlFileName}.hxml]', SUCCESS);
		SlushiUtils.printMsg("Compiling Haxe project...", INFO);

		var startTime:Float = Sys.time();

		var compileProcess = null;
		if (jsonFile.haxeConfig.debugMode) {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml', '--debug']);
		} else {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml']);
		}

		var endTime:Float = Sys.time();
		var elapsedTime:Float = endTime - startTime;
		var formattedTime:String = StringTools.trim(Math.fround(elapsedTime * 10) / 10 + "s");

		if (compileProcess != 0) {
			SlushiUtils.printMsg("Compilation failed", ERROR, "\n");
			exitCodeNum = 2;
		}

		// delete temporal hxml
		if (jsonFile.deleteTempFiles == true) {
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
			}
		}

		if (exitCodeNum == 0) {
			SlushiUtils.printMsg('Compilation successful, compilation time: ${formattedTime}\n', SUCCESS);
		}
	}

	public static function getExitCode():Int {
		return exitCodeNum;
	}

	static function finalHxLibs():String {
		var libs = "";

		for (lib in Libs.parseHXLibs()) {
			libs += lib + "\n";
		}

		return libs;
	}

	static function finalHxDefines():String {
		var defines = "";

		for (define in Defines.parseHXDefines()) {
			defines += define + "\n";
		}

		return defines;
	}

	static function finalOtherOptions():String {
		var options = "";

		for (option in Defines.parseOtherOptions()) {
			options += option + "\n";
		}

		return options;
	}
}
